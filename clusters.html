<!DOCTYPE html>
<head>
    <title>Moving Bubble Tutorial</title>
    <link rel="stylesheet" href="style/style.css" type="text/css" media="screen" />
    <meta charset="utf-8">
</head>

<body>
    
<div id="main-wrapper">
    <div id="chart"></div>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>

<script>

var margin = {top: 16, right: 0, bottom: 0, left: 0},
    width = 950 - margin.left - margin.right,
    height = 700 - margin.top - margin.bottom;
    
var node_radius = 5,
    padding = 1,
    cluster_padding = 10,
    num_nodes = 200;

var svg = d3.select("#chart").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var groups = {
    "met": { angle: Math.PI / 2, radius: 200, color: "#FF6F61", cnt: 0, fullname: "First Meeting" },
    "romantic": { angle: (3 * Math.PI) / 2, radius: 200, color: "#6B5B95", cnt: 0, fullname: "Romantic Dates" },
    "lived": { angle: 0, radius: 200, color: "#88B04B", cnt: 0, fullname: "Living Together" },
    "married": { angle: Math.PI, radius: 200, color: "#F7CAC9", cnt: 0, fullname: "Married Life" },
};


// Calculating positions for groups in a circle
const totalGroups = Object.keys(groups).length;
const angleOffset = (2 * Math.PI) / totalGroups;

Object.keys(groups).forEach((key, index) => {
    const currentAngle = index * angleOffset;
    groups[key].x = width / 2 + groups[key].radius * Math.cos(currentAngle);
    groups[key].y = height / 2 + groups[key].radius * Math.sin(currentAngle);
});



var people;
var nodes;
var node_radius = 5,
    padding = 1,
    cluster_padding = 10,
    num_nodes = 200;



d3.csv("./data/stages.csv").then(function(data) {
    people = {};
    // Gather all the same pids
    data.forEach(d => {
        if (Object.keys(people).includes(d.pid + "")) {
            people[d.pid + ""].push(d);
        } else {
            people[d.pid + ""] = [d];
        }
    });
    
    // console.log(people);


    nodes = Object.keys(people).map(function(d) {
        groups[people[d][0].grp].cnt += 1;
        return {
            id: "node"+d,
            x: groups[people[d][0].grp].x + Math.random(),
            y: groups[people[d][0].grp].y + Math.random(),
            r: node_radius,
            color: groups[people[d][0].grp].color,
            group: people[d][0].grp,
            timeleft: people[d][0].duration,
            istage: 0,
            stages: people[d]
        }
        });

    console.log(nodes);
    // Variables.
    let time_so_far = 0;

    // Circle for each node.
    const circle = svg.selectAll("circle")
        .data(nodes)
        .join("circle")
        .attr("cx", d => d.x)
        .attr("cy", d => d.y)
        .attr("fill", d => d.color);

    // Ease in the circles.
    circle.transition()
        .delay((d, i) => i * 5)
        .duration(800)
        .attrTween("r", d => {
            const i = d3.interpolate(0, d.r);
            return t => d.r = i(t);
        });

    // Group name labels.
    const groupLabels = svg.selectAll('.grp')
        .data(Object.keys(groups))
        .join("text")
        .attr("class", "grp")
        .attr("text-anchor", "middle")
        .attr("x", d => groups[d].x)
        .attr("y", d => groups[d].y - 70)
        .text(d => groups[d].fullname);

    // Group counts.
    const groupCounts = svg.selectAll('.grpcnt')
        .data(Object.keys(groups))
        .join("text")
        .attr("class", "grpcnt")
        .attr("text-anchor", "middle")
        .attr("x", d => groups[d].x)
        .attr("y", d => groups[d].y - 50)
        .text(d => groups[d].cnt);

    // Forces.
    const simulation = d3.forceSimulation(nodes)
        .force("x", d => d3.forceX(d.x))
        .force("y", d => d3.forceY(d.y))
        .force("cluster", forceCluster())
        .force("collide", forceCollide())
        .alpha(.09)
        .alphaDecay(0);

    // Adjust position of circles.
    simulation.on("tick", () => {
        circle
            .attr("cx", d => d.x)
            .attr("cy", d => d.y)
            .attr("fill", d => groups[d.group].color);
    });

    // Make time pass. Adjust node stage as necessary.
    function timer() {
        nodes.forEach(function (o) {
            o.timeleft -= 1;
            if (o.timeleft === 0 && o.istage < o.stages.length - 1) {
                // Decrease count for previous group.
                groups[o.group].cnt -= 1;
                // Update current node to a new group.
                o.istage += 1;
                o.group = o.stages[o.istage].grp;
                o.timeleft = o.stages[o.istage].duration;
                // Increment count for the new group.
                groups[o.group].cnt += 1;
            }
        });
        // Increment time.
        time_so_far += 1;
        d3.select("#timecount .cnt").text(time_so_far);
        // Update counters.
        groupCounts.text(d => groups[d].cnt);
        // Do it again.
        d3.timeout(timer, 500);
    }

    // Start things off after a few seconds.
    d3.timeout(timer, 2000);

    // Return the SVG node.
    svg.node();


    });


    function forceCluster() {
        const strength = .15;
        let nodes;

        function force(alpha) {
            const l = alpha * strength;
            for (const d of nodes) {
            d.vx -= (d.x - groups[d.group].x) * l;
            d.vy -= (d.y - groups[d.group].y) * l;
            }
        }
        force.initialize = _ => nodes = _;

        return force;
        }

    function forceCollide() {
        const alpha = 0.2; // Fixed for greater rigidity!
        const padding1 = padding; // Separation between same-color nodes
        const padding2 = cluster_padding; // Separation between different-color nodes
        let nodes;
        let maxRadius;

        function force() {
            const quadtree = d3.quadtree(nodes, d => d.x, d => d.y);

            for (const d of nodes) {
                const r = d.r + maxRadius;
                const nx1 = d.x - r, ny1 = d.y - r;
                const nx2 = d.x + r, ny2 = d.y + r;

                quadtree.visit((q, x1, y1, x2, y2) => {
                    if (!q.length) {
                        do {
                            if (q.data !== d) {
                                const r = d.r + q.data.r + (d.group === q.data.group ? padding1 : padding2);
                                let x = d.x - q.data.x, y = d.y - q.data.y, l = Math.hypot(x, y);

                                if (l < r) {
                                    l = (l - r) / l * alpha;
                                    d.x -= x *= l, d.y -= y *= l;
                                    q.data.x += x, q.data.y += y;
                                }
                            }
                        } while (q = q.next);

                        return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
                    }
                });
            }
        }

        force.initialize = _ => maxRadius = d3.max(nodes = _, d => d.r) + Math.max(padding1, padding2);

        return force;
    }



</script>

</body>
</html>
